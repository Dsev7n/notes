## 第一章 作用域是什么
#### 1.1 编译原理
+ js引擎进行编译的步骤和传统的编译语言非常相似。在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。
    + 分词/词法分析（Tokenizing/Lexing）。例如，考虑程序 var a = 2; 。这段程序通常会被分解成为下面这些词法单元： var 、 a 、 = 、 2。
        + 分词（tokenizing）和词法分析（Lexing）之间的区别是非常微妙、晦涩的，主要差异在于词法单元的识别是通过 有状态 还是 无状态 的方式进行的。简单来说，如果词法单元生成器在判断a是一个独立的词法单元还是其他词法单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为 词法分析。
    + 解析/语法分析（Parsing）。这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的“语法抽象树”（AST)。var a = 2; 的抽象语法树中可能会有一个叫作VariableDeclaration的顶级节点，接下来是一个叫作 Identifier （它的值是 a ）的子节点，以及一个叫作 AssignmentExpression的子节点。 AssignmentExpression 节点有一个叫作 NumericLiteral （它的值是 2 ）的子节点。
    + 代码生成。将 AST转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息息相关。简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指令，用来创建一个叫作a的变量（包括分配内存等），并将一个值储存在a中。关于引擎如何管理系统资源超出了我们的讨论范围，因此只需要简单地了解引擎可以根据需要创建并储存变量即可。
+ 比起那些编译过程只有三个步骤的语言的编译器，JavaScript引擎要复杂得多。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。JavaScript引擎不会有大量的（像其他语言编译器那么多的）时间用来进行优化，因为与其他语言不同，JavaScript的编译过程不是发生在构建之前的。在我们所要讨论的作用域背后，JavaScript引擎用尽了各种办法（比如 JIT，可以延迟编译甚至实施重编译）来保证性能最佳。

#### 1.2 理解作用域
+ 演员表
    + 引擎：从头到尾负责整个javascript程序的编译及执行过程
    + 编译器：引擎的好朋友之一，负责语法分析及代码生成等脏活累活
    + 作用域：编译器的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。
+ 当引擎看见var a =2；这段程序时，会认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一个则由引擎在运行时处理。事实上编译器会做如下处理：
1. 遇到 var a ，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a 。
2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量（查看 1.3节）。
3. 如果引擎最终找到了a变量，就会将2赋值给它。否则引擎就会举手示意并抛出一个异常！
+ 总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。
+ 当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。讲得更准确一点，RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS 并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧”
+ `console.log(a);`中对a的引用是一个RHS引用，需要查找并取得a的值，这样才能将值传递给console.log(..)。
+ `a = 2;`则是LHS引用，因为实际上我们并不关心当前的值是什么，只想要为=2这个赋值操作找到一个目标。
+ LHS 和 RHS 的含义并不一定意味着就是“=赋值操作符的左侧或右侧”。因此在概念上最好将其理解为“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头（RHS）”。
```
function foo(a) {
    console.log( a ); // 2
}
foo( 2 );
```
+ 上面的程序既有 LHS 也有 RHS 引用。最后一行 foo(..) 函数的调用需要对 foo 进行 RHS 引用；代码中隐式的a＝2操作可能很容易被你忽略掉。这个操作发生在 2 被当作参数传递给foo(..) 函数时，需要进行一次LHS 查询。
+  console.log(..)本身也需要一个引用才能执行，因此会对console对象进行 RHS 查询，并且检查得到的值中是否有一个叫作 log 的方法。
+  如果将函数声明`function foo(a){...`理解为`var foo、foo = function(a){..`的话，这个函数声明将需要进行LHS查询。（P24)
+  针对前面那段代码引擎和作用域的对话
```
引擎：我说作用域，我需要为 foo 进行RHS引用。你见过它吗？
作用域：别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。
引擎：哥们太够意思了！好吧，我来执行一下 foo 。
引擎：作用域，还有个事儿。我需要为 a 进行LHS引用，这个你见过吗？
作用域：这个也见过，编译器最近把它声名为 foo 的一个形式参数了，拿去吧。
引擎：大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a 。
引擎：哥们，不好意思又来打扰你。我要为 console 进行RHS引用，你见过它吗？
作用域：咱俩谁跟谁啊，再说我就是干这个。这个我也有， console 是个内置对象。
给你。
引擎：么么哒。我得看看这里面是不是有 log(..) 。太好了，找到了，是一个函数。
引擎：哥们，能帮我再找一下对 a 的RHS引用吗？虽然我记得它，但想再确认一次。
作用域：放心吧，这个变量没有变动过，拿走，不谢。
引擎：真棒。我来把 a 的值，也就是 2 ，传递进 log(..) 。
……
```
#### 1.3 作用域嵌套
+ 当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。
```
function foo(a) {
console.log( a + b );
}
var b = 2;
foo( 2 ); // 4

引擎： foo 的作用域兄弟，你见过 b 吗？我需要对它进行 RHS 引用。
作用域：听都没听过，走开。
引擎： foo 的上级作用域兄弟，咦？有眼不识泰山，原来你是全局作用域大哥，太好了。你见过 b 吗？我需要对它进行 RHS 引用。
作用域：当然了，给你吧。
```
+ 可以将程序中的作用域链形象地比喻成一个建筑，第一层楼代表当前的执行作用域，也就是你所处的位置。建筑的顶层代表全局作用域。LHS 和 RHS 引用都会在当前楼层进行查找，如果没有找到，就会坐电梯前往上一层楼，
如果还是没有找到就继续向上，以此类推。一旦抵达顶层（全局作用域），可能找到了你所需的变量，也可能没找到，但无论如何查找过程都将停止。

#### 1.4 异常
+ 如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError异常。
+ 当引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非“严格模式”下。
+ ES5 中引入了“严格模式”。同正常模式，或者说宽松/懒惰模式相比，严格模式在行为上有很多不同。其中一个不同的行为是严格模式禁止自动或隐式地创建全局变量。因此，在严格模式中LHS查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询失败时类似的 ReferenceError 异常。
+ 接下来，如果 RHS查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError 。
+ ReferenceError 同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。

## 第2章 词法作用域
+ 作用域共有两种主要工作的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域。另外一种叫作动态作用域，仍有一些编程语言在使用（比如 Bash 脚本、Perl 中的一些模式等）。

#### 2.1 词法阶段
+ 大部分标准语言编译器的第一个工作阶段叫作词法化（也叫单词化）。词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋
予单词语义。
+ 简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。
+ 后面会介绍一些欺骗词法作用域的方法，这些方法在词法分析器处理过后依
然可以修改作用域，但是这种机制可能有点难以理解。
+ 假设每一个函数都会创建一个新的作用域气泡。
+ 在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。
+ 全局变量会自动成为全局对象（比如浏览器中的window对象）的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引
用来对其进行访问。如`window.a`。通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量如果被遮蔽了，无论如何都无法被访问到。
+ 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。

#### 2.2 欺骗词法
+ 欺骗词法作用域会导致性能下降。

##### 2.2.1 eval
+ JavaScript 中的 eval(..)函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。
```
function foo(str, a) {
    eval( str ); // 欺骗！
    console.log( a, b );
}
var b = 2;
foo( "var b = 3;", 1 ); // 1, 3
```
+ eval(..) 调用中的`var b = 3;`这段代码会被当作本来就在那里一样来处理。因此它对已经存在的 foo(..) 的词法作用域进行了修改。这段代码实际上在 foo(..) 内部创建了一个变量 b ，并遮蔽了外部（全局）作用域中的同名变量。
+  eval(..) 通常被用来执行动态创建的代码，因为像例子中这样动态地执行一段固定字符所组成的代码，并没有比直接将代码写在那里更有好处。
+  在严格模式的程序中，eval(..)在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。
```
function foo(str) {
    "use strict";
    eval( str );
    console.log( a ); // ReferenceError: a is not defined
}
foo( "var a = 2" );
```
+  setTimeout(..) 和setInterval(..)的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。这些功能已经过时且并不被提倡。不要使用它们！new Function(..)函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数（前面的参数是这个新生成的函数的形参）。这种构建函数的语法比eval(..) 略微安全一些，但也要尽量避免使用。
+  在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。

##### 2.2.2 with
+ JavaScript 中另一个难以掌握（并且现在也不推荐使用）的用来欺骗词法作用域的功能是with关键字。可以有很多方法来解释with，在这里我选择从这个角度来解释它：它如何同被它所影响的词法作用域进行交互。
+ with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。比如：
```
var obj = {
    a: 1,
    b: 2,
    c: 3
};
// 单调乏味的重复 "obj"
obj.a = 2;
obj.b = 3;
obj.c = 4;
// 简单的快捷方式
with (obj) {
    a = 3;
    b = 4;
    c = 5;
}
```
+ 但实际上这不仅仅是为了方便地访问对象属性。考虑如下代码：
```
function foo(obj) {
    with (obj) {
        a = 2;
    }
}

var o1 = {
    a: 3
};

var o2 = {
    b: 3
};

foo( o1 );
console.log( o1.a ); // 2

foo( o2 );
console.log( o2.a ); // undefined
console.log( a ); // 2——不好，a 被泄漏到全局作用域上了！
```
+ 实际上 a = 2 赋值操作创建了一个全局的变量 a。with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var
声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作
用域中。
+ 另外一个不推荐使用 eval(..) 和 with 的原因是会被严格模式所影响（限
制）。 with 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用
eval(..) 也被禁止了。

##### 2.2.3 性能
+ JavaScript 引擎会在编译阶段进行数项的性能优化。如果引擎在代码中发现了 eval(..) 或 with ，它只能简单地假设关于标识符位置的判断
都是无效的，因为无法在词法分析阶段明确知道eval(..)会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给with用来创建新词法作用域的对象的内容到底是什么。最悲观的情况是如果出现了eval(..)或with，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。

## 第3章 函数作用域和块作用域
#### 3.1 函数中的作用域
+ 最常见的说法是 JavaScript 具有基于函数的作用域，意味着每声明
一个函数都会为其自身创建一个气泡（即作用域）。但事实上这并
不完全正确。
+ 函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。

#### 3.2 隐藏内部实现
+ 从一个新的角度看函数，实际的结果就是在这个代码片段的周围创建了一个作用域气泡，也就是说这段代码中的任何声明（变量或函数）都将绑定在这个新创建的包装函数的作用域中，而不是先前所在的作用域中。换句话说，可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域来“隐藏”它们。
+ 最小特权原则（或最小授权/最小暴露原则）:是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。
+ 这个原则可以延伸到如何选择作用域来包含变量和函数。如果所有变量和函数都在全局作用域中，当然可以在所有的内部嵌套作用域中访问到它们。但这样会破坏前面提到的最小特权原则，因为可能会暴漏过多的变量或函数，而这些变量或函数本应该是私有的，正确的代码应该是可以阻止对这些变量或函数进行访问的。例如：
```
function doSomething(a) {
    b = a + doSomethingElse( a * 2 );
    console.log( b * 3 );
}

function doSomethingElse(a) {
    return a - 1;
}

var b;
doSomething( 2 ); // 15
```
+ 在这个代码片段中，给予外部作用域对 b 和 doSomethingElse(..) 的“访问权限”不仅没有必要，而且可能是“危险”的，因为它们可能被有意或无意地以非预期的方式使用，从而导致超出了doSomething(..)的适用条件。更“合理”的设计会将这些私有的具体内容隐藏在 doSomething(..) 内部，例如：
```
function doSomething(a) {
    function doSomethingElse(a) {
        return a - 1;
    }
    var b;
    b = a + doSomethingElse( a * 2 );
    console.log( b * 3 );
}

doSomething( 2 ); // 15
```
##### 规避冲突
+ 两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突。
+ 软件设计在某种情况下可能自然而然地要求使用同样的标识符名称，因此在这种情况下使用作用域来“隐藏”内部声明是唯一的最佳选择。
1. 全局命名空间
+ 变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。
+ 这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴漏在顶级的词法作用域中。

2. 模块管理
+ 另外一种避免冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。它们只是利用作用域的规则强制所有标识符都不能注入到共享作用域中，而是保持在私有、无冲突的作用域中，这样可以有效规避掉所有的意外冲突。

#### 3.3 函数作用域
+ 在全局作用域声明一个具名函数虽然可以将内部的变量和函数定义“隐藏”起来，但是会导致一些额外的问题。首先，函数名这个名称本身“污染”了所在作用域。其次，必须显式地通过函数名调用这个函数才能运行其中的代码。JavaScript 提供了能够同时解决这两个问题的方案
```
var a = 2;

(function foo(){
    var a = 3;
    console.log( a );//3
    
})();

console.log( a );//2
```
+ 这里的函数会被当作函数表达式而不是一个标准的函数声明来处理。==区分函数声明和表达式最简单的方法==是看function关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。
+  (function foo(){ .. }) 作为函数表达式意味着 foo ==只能在 .. 所代表的位置中被访问==，外部作用域则不行。foo变量名被隐藏在自身中意味着不会非必要地污染外部作用域。

##### 3.3.1 匿名与具名
+ 对于函数表达式你最熟悉的场景可能就是回调参数了，比如：
```
setTimeout( function() {
    console.log("I waited 1 second!");
}, 1000 );
```
+ 这叫作匿名函数表达式.函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。
+ 匿名函数表达式书写起来简单快捷，很多库和工具也倾向鼓励使用这种风格的代码。但是它也有几个缺点需要考虑。
1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。
2. 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。
3. 匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。
+ 行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践：
```
setTimeout( function timeoutHandler() { // <-- 快看，我有名字了！
    console.log( "I waited 1 second!" );
}, 1000 );
```

##### 3.3.2 立即执行函数表达式
+  `(function foo(){ .. })() `。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数。这种模式叫IIFE，代表立即执行函数表达式。
+  函数名对 IIFE 当然不是必须的，IIFE最常见的用法是使用一个匿名函数表达式。
+  相较于传统的 IIFE 形式，很多人都更喜欢另一个改进的形式： `(function(){ .. }())`。这两种形式在功能上是一致的。选择哪个全凭个人喜好。
+  IIFE 的另一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。
```
var a = 2;
(function IIFE( global ) {
    var a = 3;
    console.log( a ); // 3
    console.log( global.a ); // 2
})( window );

console.log( a ); // 2
```
+ IIFE的另外一个应用场景是解决undefined标识符的默认值被错误覆盖导致的异常（虽然不常见）。将一个参数命名为undefined，但是在对应的位置不传入任何值，这样就可以保证在代码块中 undefined 标识符的值真的是 undefined ：
```
undefined = true; // 给其他代码挖了一个大坑！绝对不要这样做！

(function IIFE( undefined ) {
    var a;
    if (a === undefined) {
        console.log( "Undefined is safe here!" );
    }
})();
```
+ IIFE 还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE执行之后当作参数传递进去。这种模式在 UMD（Universal Module Definition）项目中被广泛使用。尽管这种模式略显冗长，但有些人认为它更易理解。???
```
var a = 2;

(function IIFE( def ) {
    def( window );
})(function def( global ) {
    var a = 3;
    console.log( a ); // 3
    console.log( global.a ); // 2
});
```

#### 3.4 块作用域
+ 除 JavaScript 外的很多编程语言都支持块作用域，表面上看 JavaScript 并没有块作用域的相关功能。除非更深入地研究。
```
for (var i=0; i<10; i++) {
    console.log( i );
}
```
+ 我们在 for 循环的头部直接定义了变量 i ，通常是因为只想在 for 循环内部的上下文中使用i，而忽略了i会被绑定在外部作用域（函数或全局）中的事实。

##### 3.4.1 with
+ with不仅是一个难于理解的结构，同时也是块作用域的一个例子（块作用域的一种形式），用 with 从对象中创建出的作用域仅在 with 声明中而非外
部作用域中有效。

##### 3.4.2 try/watch
+  JavaScript 的 ES3规范中规定try/catch的catch分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。
```
try {
    undefined(); // 执行一个非法操作来强制制造一个异常
}
catch (err) {
    console.log( err ); // 能够正常执行！
}

console.log( err ); // ReferenceError: err not found
```
+  err 仅存在 catch 分句内部，当试图从别处引用它时会抛出错误。
+  当同一个作用域中的两个或多个 catch 分句
用同样的标识符名称声明错误变量时，很多静态检查工具还是会发出警告。
实际上这并不是重复定义，因为所有变量都被安全地限制在块作用域内部。为了避免这个不必要的警告，很多开发者会将 catch 的参数命名为 err1 、
err2 等。也有开发者干脆关闭了静态检查工具对重复变量名的检查。

##### 3.4.3 let
+ let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说， let为其声明的变量隐式地创建了块作用域。
```
var foo = true;

if (foo) {
    let bar = foo * 2;
    bar = something( bar );
    console.log( bar );
}

console.log( bar ); // ReferenceError
```
+ 通常来讲，显式的代码优于隐式或一些精巧但不清晰的代码。显式的块作用域风格非常容易书写，并且和其他语言中块作用域的工作原理一致：
```
var foo = true;

if (foo) {
    { // <-- 显式的块
        let bar = foo * 2;
        bar = something( bar );
        console.log( bar );
    }
}

console.log( bar ); // ReferenceError
```
+ 只要声明是有效的，在声明中的任意位置都可以使用 { .. } 括号来为 let 创建一个用于绑定的块。在这个例子中，我们在if声明内部显式地创建了一个块，如果需要对其进行重构，整个块都可以被方便地移动而不会对外部 if 声明的位置和语义产生任何影响。
+ 使用 let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在”。
1. 垃圾收集
+ 作用域非常有用的另一个原因与闭包即回收内存垃圾的回收机制相关。这里简单说明一下，而闭包内部实现的原理会在第5章详细解释。
```
function process(data) {
    // 在这里做点有趣的事情
}

var someReallyBigData = { .. };

process( someReallyBigData );

var btn = document.getElementById( "my_button" );

btn.addEventListener( "click", function click(evt) {
    console.log("button clicked");
}, /*capturingPhase=*/false );
```
+ click 函数的点击回调并不需要someReallyBigData变量。理论上这意味着当 process(..) 执行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于 click函数形成了一个覆盖整个作用域的闭包，JavaScript 引擎极有可能依然保存着这个结构（取决于具体实现）。一个解决方法是：用块作用域可以打消这种顾虑，可以让引擎清楚地知道没有必要继续保存 someReallyBigData 了：
```
function process(data) {
    // 在这里做点有趣的事情
}

// 在这个块中定义的内容可以销毁了！
{
    let someReallyBigData = { .. };
    process( someReallyBigData );
}

var btn = document.getElementById( "my_button" );
btn.addEventListener( "click", function click(evt){
    console.log("button clicked");
}, /*capturingPhase=*/false );
```
+ 为变量显式声明块作用域，并对变量进行本地绑定是非常有用的工具。
2. let循环
+ 一个 let 可以发挥优势的典型例子就是之前讨论的 for 循环。
```
for (let i=0; i<10; i++) {
    console.log( i );
}

console.log( i ); // ReferenceError
```
+ for 循环头部的 let不仅将i绑定到了for循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。每个迭代进行重新绑定的原因非常有趣，我们会在第5章讨论闭包时进行说明。
```
{
    let j;
    for (j=0; j<10; j++) {
        let i = j; // 每个迭代重新绑定！
    console.log( i );
    }
}
```
+ 由于 let 声明附属于一个新的作用域而不是当前的函数作用域（也不属于全局作用域），当代码中存在对于函数作用域中let声明的隐式依赖时，就会有很多隐藏的陷阱，如果用let来替代var则需要在代码重构的过程中付出额外的精力。

##### 3.4.4 const
+ ES6 还引入了 const，同样可以用来创建==块作用域变量==，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误。
```
var foo = true;

if (foo) {
    var a = 2;
    const b = 3; // 包含在 if 中的块作用域常量
    a = 3; // 正常 !
    b = 4; // 错误 !
}

console.log( a ); // 3
console.log( b ); // ReferenceError!
```

## 第4章 提升
#### 4.1 先有鸡还是先有蛋
#### 4.2 编译器再度来袭
+ 引擎会在解释 JavaScript代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。因此，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。
+ 当你看到 var a = 2; 时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个声明： var a;和a=2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。
+ 只有声明本身会被提升，函数声明也会被提升，每个作用域都会进行提升操作。因此：
```
foo();
function foo() {
    console.log( a ); // undefined
    var a = 2;
}

等价于

function foo() {
    var a;
    console.log( a ); // undefined
    a = 2;
}
foo();
```
+ 函数声明会被提升，但是函数表达式不会被提升。
```
foo(); // 不是 ReferenceError, 而是 TypeError!

var foo = function bar() {
    // ...
};
```
+ 即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用:
```
foo(); // TypeError
bar(); // ReferenceError
var foo = function bar() {
    // ...
};

等价于

var foo;

foo(); // TypeError
bar(); // ReferenceError

foo = function() {
    var bar = ...self...
    // ...
}
```
#### 4.3 函数优先
+ 函数声明和变量声明都会被提升，但是函数会首先被提升，然后才是变量。
```
foo(); // 1

var foo;

function foo() {
    console.log( 1 );
}

foo = function() {
    console.log( 2 );
};
```
+ 重复的var 声明会被忽略掉，但出现在后面的函数声明是可以覆盖前面的。
```
foo(); // 3

function foo() {
    console.log( 1 );
}

var foo = function() {
    console.log( 2 );
};

function foo() {
    console.log( 3 );
}
```
+ 一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代码暗示的那样可以被条件判断所控制:(但是需要注意这个行为并不可靠，在 JavaScript未来的版本中有可能发生改变，因此应该尽可能避免在块内部声明函数)????
```
foo(); // "b"

var a = true;
if (a) {
    function foo() { console.log("a"); }
}
else {
    function foo() { console.log("b"); }
}
```

## 第5章 作用域闭包
#### 5.1 启示
+ 闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿来识别、拥抱和影响闭包的思维环境。

#### 5.2 实质问题
+ 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。

#### 5.3 现在我懂了
+ 本质上无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一
级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！

#### 5.4 循环和闭包
```
for (var i=1; i<=5; i++) {
    setTimeout( function timer() {
        console.log( i );
    }, i*1000 );
}
```
+ 这段代码在运行时会以每秒一次的频率输出五次6。代码中到底有什么缺陷导致它的行为同语义所暗示的不一致呢？
+ 缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个 i 的副本。但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i 。缺陷是什么？我们需要更多的闭包作用域，特别是在循环的过程中每个迭代都需要一个闭包作用域。
+ IIFE 会通过声明并立即执行一个函数来创建作用域。我们来试一下：
```
for (var i=1; i<=5; i++) {
    (function() {
        setTimeout( function timer() {
            console.log( i );
        }, i*1000 );
    })();
}
```
+ 这样不行。但是为什么呢？我们现在显然拥有更多的词法作用域了。的确
每个延迟函数都会将IIFE在每次迭代中创建的作用域封闭起来。如果作用域是空的，那么仅仅将它们进行封闭是不够的。它需要包含一点实质内容才能为我们所用。
```
for (var i=1; i<=5; i++) {
    (function() {
        var j = i;
        setTimeout( function timer() {
            console.log( j );
        }, j*1000 );
    })();
}

改进一下
for (var i=1; i<=5; i++) {
    (function(j) {
        setTimeout( function timer() {
            console.log( j );
        }, j*1000 );
    })( i );
}
```
+ 在迭代内使用 IIFE会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。

##### 重返块作用域
+ 我们使用 IIFE 在每次迭代时都创建一个新的作用域。换句话说，每次迭代我们都需要一个块作用域。第3章介绍了let声明，可以用来劫持块作用域，并且在这个块作用域中声明一个变量。本质上这是将一个块转换成一个可以被关闭的作用域。
```
for (var i=1; i<=5; i++) {
    let j = i; // 是的，闭包的块作用域！
    setTimeout( function timer() {
        console.log( j );
    }, j*1000 );
}
```
+ for 循环头部的 let声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。以上的代码可以更简洁：
```
for (let i=1; i<=5; i++) {
    setTimeout( function timer() {
        console.log( i );
    }, i*1000 );
}
```
#### 5.5 模块
```
function CoolModule() {
    var something = "cool";
    var another = [1, 2, 3];
    
    function doSomething() {
        console.log( something );
    }
    
    function doAnother() {
        console.log( another.join( " ! " ) );
    }
    
    return {
        doSomething: doSomething,
        doAnother: doAnother
    };
}

var foo = CoolModule();

foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
```
+  CoolModule() 返回一个用对象字面量语法 { key: value, ... } 来表示的对象。这个==返回的对象中含有对内部函数而不是内部数据变量的引用==。我们保持==内部数据变量是隐藏且私有的状态==。可以将这个对象类型的返回值看作本质上是模块的公共 API。
+  模块模式需要具备两个必要条件：
1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。
2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。
+ 上例中CoolModule()是一个独立的模块创建器，可以被调用任意多次，每次调用都会创建一个新的模块实例。当只需要一个实例时，可以把这个模式改进为单例模式,我们将模块函数转换成了IIFE，立即调用这个函数并将返回值直接赋值给单例的模块实例标识符 foo :
```
var foo = (function CoolModule() {
    var something = "cool";
    var another = [1, 2, 3];
    
    function doSomething() {
        console.log( something );
    }
    
    function doAnother() {
        console.log( another.join( " ! " ) );
    }
    
    return {
        doSomething: doSomething,
        doAnother: doAnother
    };
})();

foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
```
+ 模块模式另一个简单但强大的变化用法是，命名将要作为公共 API 返回的对象：
```
var foo = (function CoolModule(id) {
    function change() {
    // 修改公共 API
        publicAPI.identify = identify2;
    }
    
    function identify1() {
        console.log( id );
    }
    
    function identify2() {
        console.log( id.toUpperCase() );
    }
    
    var publicAPI = {
        change: change,
        identify: identify1
    };
    return publicAPI;
})( "foo module" );

foo.identify(); // foo module
foo.change();
foo.identify(); // FOO MODULE
```
##### 5.5.1 现代的模块机制
```
var MyModules = (function Manager() {
    var modules = {};
    
    function define(name, deps, impl) {
        for (var i=0; i<deps.length; i++) {
            deps[i] = modules[deps[i]];
        }
        modules[name] = impl.apply( impl, deps );
    }
    
    function get(name) {
        return modules[name];
    }
    
    return {
        define: define,
        get: get
    };
})();
```
+ 下面展示了如何使用它来定义模块：
```
MyModules.define( "bar", [], function() {
    function hello(who) {
        return "Let me introduce: " + who;
    }
    return {
        hello: hello
    };
} );

MyModules.define( "foo", ["bar"], function(bar) {
    var hungry = "hippo";
    
    function awesome() {
        console.log( bar.hello( hungry ).toUpperCase() );
    }
    
    return {
        awesome: awesome
    };
} );

var bar = MyModules.get( "bar" );
var foo = MyModules.get( "foo" );

console.log(
    bar.hello( "hippo" )
); // Let me introduce: hippo

foo.awesome(); // LET ME INTRODUCE: HIPPO
```
##### 5.5.2 未来的模块机制
+ ES6之前基于函数的模块并不是一个能被稳定识别的模式（编译器无法识别），它们的 API 语义只有在运行时才会被考虑进来。因此可以在运行时修改一个模块的 API。
+ ES6 模块 API 更加稳定（API 不会在运行时改变）。由于编辑器知
道 这一点 ，因此可以在（的确也这样做了）编译期检查对导入模块的 API 成员的引用是否 真实存在。如果API引用并不存在，编译器会在运行时抛出一
个或多个“早期”错误，而不会像往常一样在运行期采用动态的解决方案。通过模块系统进行加载时，ES6 会将文件当作独立的模块来处理。
+ ES6 的模块没有“行内”格式，必须被定义在独立的文件中（一个文件一个模块）。浏览器或引擎有一个默认的“模块加载器”（可以被重载，但这远超出了我们的讨论范围）可以在导入模块时异步地加载模块文件。
```
bar.js
    function hello(who) {
        return "Let me introduce: " + who;
    }
    export hello;

foo.js
// 仅从 "bar" 模块导入 hello()
    import hello from "bar";
    
    var hungry = "hippo";
    
    function awesome() {
        console.log(
        hello( hungry ).toUpperCase()
        );
    }
    
    export awesome;
    
    
baz.js
// 导入完整的 "foo" 和 "bar" 模块
    module foo from "foo";
    module bar from "bar";
    
    console.log(
        bar.hello( "rhino" )
    ); // Let me introduce: rhino
    
    foo.awesome(); // LET ME INTRODUCE: HIPPO
```
+ import 可以将一个模块中的一个或多个API导入到当前作用域中，并分别绑定在一个变量上（在我们的例子里是 hello ）。 module 会将整个模块的 API 导入并绑定到一个变量上（在我们的例子里是 foo 和 bar ）。 export 会将当前模块的一个标识符（变量、函数）导出为公共 API。
+ 模块文件中的内容会被当作好像包含在作用域闭包中一样来处理，就和前面介绍的函数闭包模块一样。
+ 使用闭包的缺点及解决方法：
1. 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，==在退出函数之前，将不使用的局部变量全部删除==。
2. 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。