
> 《图解HTTP》
## 第一章 了解web及网络基础
### 1.3 网络基础tcp/ip
#### 1.3.2 tcp/ip的分层管理
+ TCP/IP协议族各层的作用如下:
    + 应用层决定了向用户提供应用服务时通信的活动。HTTP协议处于改层。
    + 传输层提供处于网络连接中的两台计算机之间的数据传输。
    + 网络层用来处理在网络上流动的数据包。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。网络层所起的作用就是在众多的选项内选择一条传输路线。
    + 链路层（又称数据链路层）用来处理连接网络的硬件部分。

### 1.4 与HTTP关系密切的协议：IP、TCP和DNS
#### 1.4.1 负责传输的IP协议
+ IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址，IP地址可以和MAC地址进行配对，IP地址可变换，但MAC地址基本上不会更改。
+ ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。
#### 1.4.2 确保可靠性的TCP协议
+ 计网P238

### 1.5 负责域名解析的DNS服务
+ DNS服务位于应用层，提供域名到IP地址之间的解析服务。用户通常使用主机或域名访问对方的计算机，而不是直接通过IP地址访问。

### 1.6 各种协议与HTTP协议的关系
![image](https://wx2.sinaimg.cn/mw690/005PH614ly1g0pvotns41j30c20ftdj0.jpg)
+ TCP是传输层，而http是应用层，http是要基于TCP连接基础上的，简单的说，TCP就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。http是用来收发数据。
### 1.7 URI和URL
+ URI就是由某个协议方案表示的资源的定位标识符，协议方案是指访问资源所使用的协议类型名称。URI用字符串标识某一互联网资源，而URL表示资源的地点（互联网上所处的位置）。可见URL是URI的子集。

#### 1.7.2 URI格式
+ URI的格式
![image](https://wx1.sinaimg.cn/mw690/005PH614ly1g0pvzw33lyj30dv02x74y.jpg)
+ 服务器地址：使用绝对URI必须指定待访问的服务器地址。地址可以是类似hackr.jp这种DNS可解析的名称，或是192.168.1.1这类IPv4地址名，还可以是[0:0:0:0:0:0:0:1]这样用方括号括起来的IPv6地址名。
+ 服务器端口号：指定服务器连接的网络端口号。此项是可选项，若用户冷落则自动使用默认端口号。

## 第2章 简单的HTTP协议
+ HTTP请求报文和响应报文的例子：
    + 计网P271-273

### 2.3 HTTP是不保存状态的协议
+ 服务器并不记得曾经访问过的这个客户，也不记得为该客户曾经服务过多少次。HTTP的无状态特性简化了服务器的设计，使服务器更容易支持大量并发的HTTP请求。
+ HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，引入了cookie技术。

### 2.5 告知服务器意图的HTTP方法
+ 使用GET方法的请求-响应的例子
![image](https://wx3.sinaimg.cn/mw690/005PH614ly1g0pwn0znqaj30fe06bdhi.jpg)
+ PUT方法用来传输文件，就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。但是，鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的WEB网站不使用该方法。
+ HEAD:获得报文首部
+ DELETE：删除文件
+ OPTIONS：询问支持的方法  
+ 方法名区分大小写，主要要使用大写字母。

### 2.7 持久连接节省通信量
#### 2.7.1 持久连接
> 《HTTP权威指南》

+ HTTP Keep-alive持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。
+ 持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。而且，已经打开的连接可以避免慢启动的拥塞适应阶段，以便更快速地进行数据的传输。
+ 实现HTTP/1.0 keep-alive连接的客户端可以通过包含Connection:Keep-Alive首部请求将一条连接保持在打开状态。如果服务器愿意为下一条连接保持在打开状态，就在响应中包含相同的首部。如果响应中没有Connection:Keep-Alive首部，客户端就认为服务器不支持keep-alive，就会在发回响应报文之后关闭连接。
    + 参数timeout是在Keep-Alive响应首部发送的。单位为秒。它估计了服务器希望将连接保持在活跃状态的时间。这并不是一个承诺值。
    + 参数max是在Keep-Alive响应首部发送的。它估计了服务器还希望为多少个事务保持此连接的活跃状态。这并不是一个承诺值。
+ Keep-Alive首部完全是可选的，但只有提供Connection:Keep-Alive时才能使用它。
```
 //服务器最多还会为另外5个事务保持连接的打开状态
 //或者打开状态保持到连接空闲了2分钟之后
Connection:Keep-Alive
Keep-Alive:max=5, timeout=120 
```
+ 该头部是HTTP/1.0增加的，在HTTP/1.1中，所有的连接默认都是持久连接，除非在请求或响应的Header中指明要关闭：Connection: Close，但在HTTP/1.0内并未标准化。

### 2.7.2 管线化
+ 持久连接使得多数请求以管线化方式发送成为可能，这样能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。

## 第3章 HTTP报文内的HTTP信息
### 3.3 编码提升传输速率
#### 3.3.1 报文主体和实体主体的差异
+ 报文（message）是HTTP通信中的基本单位，有8位组字节流组成，通过HTTP通信传输
+ 实体（entity)作为请求或响应的有效载荷数据（补充项）被传输，其内容由首部和实体主体组成。
+ HTTP报文的主体用于 传输 请求或响应的实体主体。通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。

#### 3.3.2 压缩传输的内容编码
+ 内容编码指明应用在实体内容上的编码格式，并保持实体信息鸳鸯压缩，内容编码后的实体由客户端接收并负责解码。
+ 常见的内容编码由以下几种：
    + gzip
    + compress(UNIX系统的标准压缩)
    + deflate（zlib）
    + identity(不进行编码)

#### 3.3.3 分割发送的分块传输编码

### 3.4 发送多种数据的多部分对象集合
+ MIME(Mutipurpose Internet Mail Extentions,多用途因特网邮件扩展)机制，允许邮件处理文本、图片、视频等多个不同类型的数据。MIME扩展中会使用一种称为多部分对象集合（Mutipart)的方法，来容纳多份不同类型的数据。
+ HTTP协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型主体。通常是在图片或文本文件等上传时使用。多部分对象集合包含的对象如下：
    + mutipart/form-data:在Web表单文件上传时使用
    + mutipart/byteranges：状态码206（部分内容）响应报文包含了多个范围的内容时使用。
+ 在HTTP报文中使用多部分对象集合时。需要在首部字段里加上Content-type。值为上面的两个选项。

### 3.5 获取部分内容的范围请求
+ 下载过程中遇到网络中断的情况，能从之前下载中断处恢复下载。执行范围请求时，会用到首部字段Range来指定资源的byte范围。byte范围的指定形式如下：
```
Range:bytes=5001-10000   //5001~10000字节

Range:bytes=5001-     //从5001字节之后全部的

Range:bytes=-3000,5000-7000   //一开始到3000字节和5000~7000字节的多重范围
```
+ 针对范围请求，响应会返回状态码为206Partial Content的响应报文。另外，对于多重范围的范围请求，响应会在首部字段Content-Type表明mutipart/byteranges后返回响应报文。如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容。

### 3.6 内容协商返回最合适的内容
+ 当浏览器的默认语言为英语或中文，访问相同URI的Web页面时，则会显示对应的英语班或中文版的页面。这样的机制称为内容协商。内容协商是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。内容协商会以响应资源的语言、字符集、编码方式作为判断的基准。
    + Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Language.
+ 内容协商技术有三种类型：
    + 服务器驱动协商
    + 客户端驱动协商
    + 透明协商

## 第4章 返回结果的HTTP状态码
### 4.1 状态码告知从服务器端返回的请求结果
+ 状态码的类别
--| 类别
---|---
1XX | 接收的请求正在处理
2XX | 成功状态码。请求正常处理完毕
3XX | 重定向状态码，需要进行附加操作以完成请求
4XX | 客户端错误状态码
5XX | 服务器错误状态码
+ 经常使用的状态码大概只有14种

### 4.2 2XX 成功
+ ==200 OK==：请求已正常处理
+ ==204 No Content==: 服务器处理成功，但没有资源可返回。一般在只需要从客户端往服务器发送信息的情况下使用。
+ ==206 Partial Content==:该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。

### 4.3 3XX 重定向
+ ==301 Moved Permanently==:永久性重定向，如果已经把资源对应的URI保存为输钱了，这时应该按Location首部字段提示的URI重新保存。当指定资源路径的最后忘记添加斜杠“\”，就会产生301状态码。`http://example.com/sample`
+ ==302 Found==:临时性重定向。
+ ==303 See Other==:该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。
+ 当301、302、303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。
+ ==304 Not Modified==:客户端发送附带条件的请求，采用GET方法的请求报恩中共包含If-Match,If-Modified-Since, If-None-Match,If-Range,If-Unmodified-Since中任一首部。

### 4.4 4XX 客户端错误
+ ==400 Bad Request==:请求报文存在语法错误。
+ ==401 Unauthorized==:发送的请求需要有通过HTTP认证（BASI认证、DIGEST认证）的认证信息。若之前已进行过1次请求，则表示用户认证失败。
+ ==403 Forbidden==:表明对请求资源的访问被服务器拒绝了，没有必要给出拒绝的详细理由。未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源IP地址试图访问）等列举的情况都可能是发生403的原因。
+ ==404 Not Found==:服务骑上无法找到请求的资源。

### 4.5 5XX 服务器错误
+ ==500 Internet Server Error==:表明服务器端在执行请求时发生了错误，也有可能是Web 应用存在的bug或某些临时的故障。
+ ==503 Service Unavailable==:表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

## 第5章 与HTTP协作的Web服务器
### 5.1 用单台虚拟主体实现多个域名
+ 提供Web托管服务的供应商，可以用一台服务器为多位客户服务，也可以以每位客户持有的域名运行各自不同的网站。这是因为李永乐路虚拟主机（又称虚拟服务器）的功能。

### 5.2 通信数据转发程序：代理、网关、隧道
+ 代理服务器的基本行为就是接受客户端发送的请求后转发给其他服务器。持有资源实体的服务器被称为源服务器。转发时，需要附加Via首部字段以标记出经过的主机信息。
![image](https://wx2.sinaimg.cn/mw690/005PH614ly1g0qx56v9uej30fs06676s.jpg)
+ 代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文。
    + 缓存代理：代理转发响应时，缓存代理会预先将资源的副本保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器哪里获取资源，而是将之前缓存的资源作为响应返回。
    + 透明代理：不对报文做任何加工的代理类型。
+ 利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用SQL语句查询数据。另外，在Web购物网站上进行银行卡结算时，网关可以和信用卡结算系统联动。
![image](https://wx3.sinaimg.cn/mw690/005PH614ly1g0qx8mj10pj30ez04z3zn.jpg)

### 5.3 保存资源的缓存
+ 缓存是指代理服务器或客户端本地磁盘内保存的资源副本。

## 第6章 HTTP首部
### 6.3 HTTP/1.1 通用首部字段
#### 6.3.1 Cache-Control
+ 指令的参数是可选的，多个指令之间通过逗号分隔。
```
Cache-Control:private, max-age=0, no-cache
```
+ 缓存请求指令：

指令 | 说明
---|---
no-cache | 强制向源服务器再次请求
no-store | 不缓存请求或响应的任何内容
max-age = [秒] | 响应的最大Age值
max-stale = ([秒]) | 接收已过期的响应
min-fresh = [秒] | 期望在指定时间内的响应仍有效
no-transform | 代理不可更改媒体类型
only-if-cached | 从缓存获取资源
cache-extension | 新指令标记（token）
+ 缓存响应指令：

指令 | 说明
---|---
public | 可向任意方提供响应的缓存
private | 仅向特定用户返回响应
no-cache | 缓存前必须==先确认其有效性==
no-store | ==不缓存==请求或响应的任何内容
no-transform | 代理不可更改媒体类型
must-revalidate | 可缓存但必须向源服务器进行确认
proxy-revalidate | 要求中间缓存服务器对缓存的响应有效性再进行确认
max-age = [秒] | 响应的最大Age值
s-maxage = [秒] | 公共服务器响应的最大Age值
cache-extension | 新指令标记（token)
+ 使用no-cache指令的目的是为了防止从缓存中返回过期的资源。
    + 客户端的请求中如果包含no-cache指令，中间的缓存服务器必须把客户端的请求转发给源服务器。
    + 如果服务器的响应中国包含no-cache指令，那么禁止缓存服务器对资源进行缓存。源服务器以后也将不再确认资源的有效性。
    + 响应头中的Cache-control字段如果对no-cache字段名指定参数值，那么客户端不能缓存该参数的首部？
+ s-maxage指令只适用于供多位用户使用的公共缓存服务器。当使用s-maxage指令后，则直接忽略对Expires首部字段及max-age指令的处理。
![image](https://wx3.sinaimg.cn/mw690/005PH614ly1g0qyhbj5n1j30fx09m0ug.jpg)
+ 应用HTTP/1.1版本的缓存服务器遇到同时存在Expires首部字段的情况，会优先处理max-age指令，而忽略掉Expires首部字段。而HTTP/1.0版本的缓存服务器的情况却相反，max-age指令会被忽略掉。
+ cache-extension token：通过cache-extension标记（token），可以扩展Cache-Control首部字段内的指令。
```
Cache-Control:private,community="UCI"
```
+ 如上例，如果缓存服务器不能理解community这个新指令，就会直接忽略。因此，extension tokens仅对能理解它的缓存服务器来说是有意义的。

#### 6.3.2 Connection
+ Connection具有如下两个作用
    + 控制不再转发给代理的首部字段
    + 管理持久连接
![image](https://wx2.sinaimg.cn/mw690/005PH614ly1g0qzg2283hj30ge0avwh3.jpg)
+ HTTP/1.1版本的默认连接都是持久连接，HTTP/1.1之前的HTTP版本的默认连接都是非持久连接。为此，如果想在旧版本的HTTP协议上维持持久连接，需设置Keep-Alive
```
Connection:close  //服务器端想明确断开连接

Connection:Keep-Alive   //设置持久连接
```
#### 6.3.3 Date
+ Date字段表明创建HTTP报文的日期和时间。HTTP/1.1协议使用在RFC1123中规定的日期时间的格式：
```
Date: Tue, 03 Jul 2012 04:40:59 GMT
```

#### 6.3.4 Pragma
+ Pragma是HTTP/1.1之前版本的历史遗留字段，仅作为与HTTP/1.0的向后兼容而定义。该字段只用在客户端发送的请求中。要整体掌握全部中间服务器使用的HTTP协议版本是不现实的。因此，发送的请求会同时含有下面两个首部字段：
```
Cache-Control: no-cache
Pragma:no-cache
```

### 6.4 请求首部字段
#### 6.4.1 Accept 
+ Accept通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可用type/subtype这种形式，一次指定多种媒体类型，用逗号隔开。比如，如果浏览器不支持PNG图片的显示，那Accept就不指定image/png,而指定可处理的image/gif和image/jpeg等图片类型。
+ 若想要给显示的媒体类型增加优先级，使用q=来额外表示权重值，范围是0~1.不指定时默认为1.0。
+ 几个媒体类型的例子
    + 文本文件：text/html,text/plan,text/css,application/xhtml+xml,application/xml等
    + 图片文件：image/jpeg,image/gif,image/png等
    + 视频文件：video/mpeg,video/quicktime等
    + 应用程序使用的二进制文件：application/octet-stream,application/zip等

#### 6.4.2 Accept-Charset
+ 该字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。

#### 6.4.3 Accept-Encoding
+ 用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。
```
Accept-Encoding:gzip,deflate
```
+ 几个内容编码的例子：
    + gzip:由文件压缩程序gzip生成的编码格式。
    + compress:有UNIX文件压缩程序compress生成的编码格式。
    + deflate:组合使用zlib格式及由deflate压缩算法生成的编码格式。
    + identity:不执行压缩或不会变化的默认编码格式。

#### 6.4.4 Accept-Language
```
Accept-Language:zh-cn,zh;q=0.7,en-us,en;q=0.3
```

#### 6.4.5 Authorization
+ 该字段是用来告知服务器，用户代理的然后在那个信息（证书值）。

#### 6.4.6 Expect
+ 客户端使用该字段来告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码417 Expection Failed.
```
Expect:100-continue
```
#### 6.4.7 From
![image](https://wx4.sinaimg.cn/mw690/005PH614ly1g0rnd8vpjwj30dg06tgmm.jpg)

#### 6.4.8 Host
+ 该字段会告知服务器，请求的资源所处的互联网主机号和端口号。Host在HTTP/1.1规范内是==唯一一个==必须被包含在请求内的首部字段。
![image](https://wx3.sinaimg.cn/mw690/005PH614ly1g0rnh15jknj30fj09d76i.jpg)
+ 若服务器未设定主机名，那直接发送一个空值即可。
```
Host：
```

#### 6.4.9 If-Match
+ 形如If-xxx这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。
![image](https://wx3.sinaimg.cn/mw690/005PH614ly1g0rnlnso72j30fj0e7wi4.jpg)
+ 若该字段与资源的ETag不一致，会发怒会状态码412 Precondition Failed的响应。

#### 6.4.10 If-Modefied-Since
![image](https://wx3.sinaimg.cn/mw690/005PH614ly1g0rnp8q7s6j30fp0cv0w7.jpg)
+ 该字段用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段Last-Modified来确定。

#### 6.4.11 If-None-Match
+ 该字段和If-Match作用相反。

#### 6.4.12 If-Range
![image](https://wx1.sinaimg.cn/mw690/005PH614ly1g0rnw1oxoqj30g50fddk8.jpg)
+ 如果不使用If-Range,服务器的资源如果更新，那客户端持有资源中的一部分也会随之无效，服务器会暂且以状态码412Precondition Failed作为响应返回，其目的是催促客户端再次发送请求，这样一来，需要花费两倍的功夫。

#### 6.4.13 If-Unmodified-Since
#### 6.4.17 Referer
+ 改短会告知服务器请求的原始URI。

#### 6.4.19 User-Agent
+ 该字段会将创建请求的浏览器和用户代理名称等信息传达给服务器。

### 6.5 响应首部字段
#### 6.5.2 Age
+ 该字段能告知客户端，源服务器再多久前创建了响应。字段值的单位为秒。
+ 若创建该响应的服务器是缓存服务器，Age值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上Age


#### 6.5.3 ETag
+ 服务器会为每份资源分配对应的ETag值。生成ETag值时，并没有统一的算法规则，而仅仅是由服务器来分配。
+ 强ETag值，不论实体发生多么细微的变化都会改变其值。
+ 弱ETag值，只有资源发生了根本改变，产生差异时才会改变。这时，会在字段值最开始处附加W/
```
ETag："usggi-1235"   //强

ETag：W/"usggi-1235"   //弱
```

#### 6.5.4 Location
![image](https://wx2.sinaimg.cn/mw690/005PH614ly1g0roh08bv2j30fm0gxtcn.jpg)
+ 基本上，该字段会配合3XX:Redirection的响应，提供重定向的URI

#### 6.5.8 Vary
![image](https://wx1.sinaimg.cn/mw690/005PH614ly1g0roli7lw1j30f70angoy.jpg)

### 6.6 实体首部字段
#### 6.6.1 Allow
+ 该字段用于通知客户端能够支持Request-URI指定资源的所有HTTP方法，当服务器接收到不支持的HTTP方法时，会以405 Method Not Allowed作为响应返回。与此同时，还会把所有能支持的HTTP方法写入首部字段Allow后返回。

#### 6.6.6 Content-MD5
![image](https://wx3.sinaimg.cn/mw690/005PH614ly1g0rotplhl4j30fe09sq4y.jpg)
+ 该字段是一串由MD5算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。
+ 对报文主题执行MD5算法获得的128位二进制数，再通过Base64编码后将结果写入Content-MD5字段值。由于HTTP首部无法记录二进制值，所以要通过Base64编码处理，为确保报文的有效性，作为接收方的客户端会对报文主体再执行一次相同的MD5算法。计算出的值与字段值作比较后，即可判断出报文主体的准确性。
+ 采用这种方法，对内容上的偶发性改变时无从查证的，也无法检测出恶意篡改，其中一个原因在于，内容如果能够被篡改，那么同时意味着Content-MD5也可重新计算然后被篡改。所以处在接收阶段的客户端是无法意识到报文主体以及首部字段Content-MD5是已经被篡改过的。

#### 6.6.9 Expires
+ 缓存服务器在接收到含有首部字段Expires的响应后，在该字段指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。
+ 源服务器不希望缓存服务器对资源缓存时，最好在Expires字段内写入与首部字段Date相同的时间值。
+ 但是，当首部字段Cache-Control有指定max-age指令时，比起Expires，会优先处理max-age指令。

#### 6.6.10  强缓存与协商缓存
> 参考链接：https://www.jianshu.com/p/1a1536ab01f1
+ 强缓存：实体首部Expires,通用首部Cache-Control
+ 弱缓存：Last-Modify+If-Modefied-Since, If-None-Match+ETag
+ 浏览器缓存过程：
1. 浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；
2. 下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求
3. 服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200；
4. 如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200



## 第7章 确保Web安全的HTTPS
+ HTTP的不足：
    + 通信使用明文（不加密），内容可能会被窃听。
    + 不验证通信方的省份，因此也可能遭遇伪装。
    + 无法证明报文的完整性，所以有可能已遭篡改。

#### 7.1.1 通信使用明文可能会被窃听
##### 加密处理防止被窃听
+ 通信的加密：HTTP通过和SSL（Secure Socket Layer,安全套接层）或TLS（Transport Layer Security,安全层传输协议）的组合使用，建立安全通信线路，成为HTTPS。
+ 内容的加密：为了做到有效的内容加密，前提是要求客户端和服务器同时具备加密和解密机制。客户端需要对HTTP报文进行加密处理后再发送请求。该方式不同于SSL或TLS将整个通信线路加密处理，所以内容仍有被篡改的风险。

#### 7.1.2 不验证通信方的身份就可能遭遇伪装
##### 查明对手的证书
+ SSL不仅提供加密处理，而且还使用了一种被称为证书的手段。证书由值得信任的第三方机构颁发，用以证明服务器和客户端时实际存在的。另外，伪造证书从技术角度来说是异常困难的一件事，所以只要能够确认通信方持有的证书，即可判断通信方的真实意图。

#### 7.1.3 无法证明报文完整性，可能已遭篡改。
##### 如何防止篡改
+ 虽然有使用HTTP协议确定报文完整性的方法，但事实上并不便捷、可靠。其中常用的是MD5和SHA-1等散列值校验的方法，以及用来确认文件的数字签名方法。

### 7.2 HTTP+加密+认证+完整性保护 = HTTPS
+ HTTPS并非应用层的一种新协议。知识HTTP通信接口部分用SSL或TLS协议代替而已。通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通新，再由SSL和TCP通信了。
![image](https://wx1.sinaimg.cn/mw690/005PH614ly1g0rx6iqosgj30cw069wfa.jpg)

#### 7.2.3 相互交换密钥的公开密钥加密技术
+ SSL采用一红叫做公开密钥加密的加密处理方式。近代的加密方法中加密算法是公开的，而密钥却是保密的。加密和解密都会用到密钥。

##### 共享密钥加密的困境
+ 加密和解密同用一个密钥的方式成为共享密钥加密，也称对称密钥加密。
+ 以共享密钥加密方式加密必须将密钥也发给对方，可究竟怎样才能安全地转交？

##### 使用两把密钥的公开密钥加密
+ 公开密钥加密方式很好地解决了共享密钥加密的困难。公开密钥加密使用一对非对称的密钥，一把叫做私有密钥，一把叫做公开密钥。私有秘钥不能让任何人知道，而公开密钥则可以随意发布。
+ 使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有秘钥记性解密。
+ 要想根据密文和公开密钥，恢复到信息原文是异常困难的。因为解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。就目前的技术来看是不太现实的。

##### HTTPS采用混合加密机制
+ 公开密钥加密与共享密钥加密相比，其处理速度要慢。HTTPS充分利用两者各自的优势，在交换密钥换届使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。

#### 7.2.4 证明公开密钥正确性的证书
+ 正准备和某台服务器建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者换掉了。这时，可以使用由数字证书认证机构（CA,Certificate Authority)和其相关机关颁发的公开密钥证书。
+ 数字证书认证机构的业务流程：首先，服务器的运营人员向数字战术认证机构提供公开密钥的申请，数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入密钥证书后绑定在一起。
+ 服务器会将这份数字证书认证机构颁发的公钥证书发送给客户端，已进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书。
+ 接到证书的客户端可使用数字证书机构的公开密钥，对那张证书上数字签名进行验证，一旦验证通过，客户端便可明确两件事：一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二，服务器的公开密钥是值得信赖的。
+ 此处认证机关的公开密钥必须安全地转交给客户端。。多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。

##### 可证明组织真实性的EV SSL证书
+ 证书的一个作用是用来证明作为通信一方的服务器是否规范，另外一个作用是可确认对方服务器背后运营的企业是否真实存在。拥有该特性的证书就是EV SSL证书。
+ EV SSL证书是基于国际标准的认证指导方针颁发的证书。
+ 持有EV SSL证书的Web网站的浏览器地址栏处的背景色是绿色的，而且在地址栏的左侧显示了SSL证书中记录的组织名称及办法证书的认证机构的名称。

##### 用以确认客户端的客户端证书
+ 安全性极高的认证机构可颁发客户端证书但仅用于特殊用途的业务，比如那些课支撑客户端证书支出费用的业务。
+ 例如，银行的网上银行就采用了客户端证书。在登录网银时不仅要求用户确认输入ID和密码，还会要求用户的客户端在证书，以确认用户是否从特定的终端访问网银。
+ 客户端证书毕竟只能用来证明客户端实际存在，而不能用来证明用户本人的真实有效性。
+ 为什么不一直使用HTTPS？
    + 和纯文本通信相比，加密通信会消耗更多的CPU及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定会随之减少。
    + 想要节约购买证书的开销也是原因之一。那些购买证书并不合算的服务以及一些个人网站，可能只会选择采用HTTP的通信方式。


## 第8章 确认访问用户身份的认证
### 8.1 何为认证
+ 未确认使用者本人是是否真的具有访问系统的权限，就需要核对登陆者本人才知道的信息，核对的信息通常是指：密码、动态令牌、数字证书、生物认证、IC卡等。
+ HTTP/1.1使用的认证方式如下：
    + BASIC认证（基本认证）
    + DIGEST认证（摘要认证）
    + SSL客户端认证
    + FormBase认证（基于表单认证）

### 8.2 BASIC认证
![image](https://wx3.sinaimg.cn/mw690/005PH614ly1g0ss4gbxa2j30fv0b0wh8.jpg)
+ 状态码401返回带WWW-Authenticate首部字段，该字段内包含认证的方式（BASIC)及Request-URI安全域字符串。
+ 发送的字符串由用户ID和密码构成，两者中间以冒号连接。当用户代理为浏览器时，用户仅需输入用户ID和密码即可，之后，浏览器会自动完成到Base64编码的转换工作。并把其放入Authorization字段中。
+ BASIC认证虽然采用Base64编码方式，但这不是加密处理。不需要任何附加信息即可对其解码。除此之外想再进行一次BASIC认证时，一般的浏览器却无法实现认证注销操作，这也是问题之一。
+ BASIC认证使用上不够便捷灵活，且达不到多数Web网站期望的安全性等级，因此它并不常用。

### 8.3 DIGEST认证

### 8.4 SSL客户端认证

### 8.5 基于表单认证
+ 基于表单的认证方法并不是HTTP协议的内容。客户端会向服务器上的Web程序发送登录信息，按登录信息的验证结果认证。

#### 8.5.1 认证多半为基于表单认证
+ 由于使用上的便利性即安全性问题，HTTP协议标准提供的BASIC认证和DIGEST认证几乎不怎么使用。另外，SSL客户端认证虽然具有高度的安全等级，但因为导入及维持费用等问题，还尚未普及。


## 从输入url到页面展示到底发生了什么
> + 参考链接:
> + https://www.jianshu.com/p/23b388f8e5aa
> + https://juejin.im/post/5bbaa549e51d450e827b6b13?utm_source=gold_browser_extension
> + https://www.cnblogs.com/qcloud1001/p/10265985.html

1. 域名解析
2. 向WEB服务器发送HTTP请求
3. 服务器处理请求
4. 服务器返回HTTP响应
5. 浏览器显示页面信息

### 浏览器查找域名的IP地址
1. 首先会在浏览器的缓存中查找是否有该域名对应的IP地址，如果有，则直接返回该IP地址；如果没有，则查找本地硬盘上的hosts文件中是否有，如果有，则返回对应的IP地址；如果没有，则查找路由器缓存中是否有对应的IP地址，如果有，则返回；
2. 如果在浏览器缓存中、hosts文件中、路由器缓存中都没有找到ip地址，则浏览器会发起一个DNS请求到本地DNS服务器，本地DNS服务器一般是由你的网络接入服务器商提供，如：电信、移动；
3. DNS请求到达本地DNS服务器后，本地DNS服务器会先在自己的缓存中查找，如果找到了就返回找到的IP,这个过程是以递归的方式进行的；如果没有，则本地DNS服务器继续向根DNS服务器发起请求；
4. 根DNS服务器并没有记录域名与IP的对应关系，而是告诉本地DNS服务器，可以到哪个顶级域名服务器上查询，并给出该顶级域名服务器的地址，此过程是以迭代的方式进行的；
5. 本地DNS继续向顶级域名服务器发出查询请求，顶级域名服务器接收到请求后，会告诉本地DNS到权限域名服务器上去查询；
6. 本地DNS继续向权限域名服务器发出查询请求，权限域名服务器查询到域名对应的IP后，将IP地址返回给本地DNS，本地DNS接收后将其保存到自己的缓存中，以备下次查询，提高查询速度；至此，一个IP地址的查询就此结束；

### 浏览器显示HTML

![image](https://user-gold-cdn.xitu.io/2018/10/8/166511304b1b6c20?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
+ HTML parser：HTML解析器，其本质是将HTML文本解释成DOM tree。
+ CSS parser：CSS解析器，其本质是讲DOM中各元素对象加入样式信息
+ DOM tree:文档对象模型树，也就是浏览器通过HTMLparser解析HTML页面生成的HTML树状结构以及相应的接口。
+ render tree：渲染树，也就是浏览器引擎通过DOM Tree和CSS Rule Tree构建出来的一个树状结构，和dom tree不一样的是，它只有要最终呈现出来的内容，像或者带有display:none的节点是不存在render tree中的。
+ reflow：回流，渲染中的一种行为。当render tree中任一节点的几何尺寸发生改变了，render tree都会重新布局。
+ repaint：重绘，渲染中的一种行为。render tree中任一元素样式属性（几何尺寸没改变）发生改变了，render tree都会重新画，比如字体颜色、背景等变化。
+ 浏览器解析渲染页面主要包括以下过程：
1. 浏览器通过HTMLParser根据深度遍历的原则把HTML解析成DOM Tree。
2. 将CSS解析成CSS Rule Tree（CSSOM Tree）。
3. 根据DOM树和CSSOM树来构造render Tree。
4. layout：根据得到的render tree来计算所有节点在屏幕的位置。
5. paint：遍历render树，并调用硬件图形API来绘制每个节点。
+ 为了构建渲染树，浏览器主要完成了以下工作：
    1. 从DOM树的根节点开始遍历每个可见节点。
    2. 对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。、
    3. 根据每个可见节点以及其对应的样式，组合生成渲染树。
+ 不可见的节点包括：
    + 一些不会渲染输出的节点，比如script、meta、link等。
    + 一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。

##### ==回流与重绘==
+ 通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。何时发生回流？
    + 添加或删除可见的DOM元素
    + 元素的位置发生变化
    + 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
    + 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
    + 页面一开始渲染的时候（这肯定避免不了）
    + 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）
+ 通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。
+ **回流必将引起重绘，而重绘不一定会引起回流**。回流可以理解为render树的结构发生了变化，需要重新构建；而重绘就是结构没有变化，只是一些对结构布局没有产生影响的元素发生了变化（如：字体颜色）
+ ==浏览器的优化机制==：由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法：
    + offsetTop、offsetLeft、offsetWidth、offsetHeight
    + scrollTop、scrollLeft、scrollWidth、scrollHeight
    + clientTop、clientLeft、clientWidth、clientHeight
    + getComputedStyle()
    + getBoundingClientRect
+ 以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，**最好避免使用上面列出的属性，他们都会刷新渲染队列**。如果要使用它们，最好将值缓存起来。
##### ==减少回流和重绘==
+ **最小化重绘和回流**
    + 使用cssText
    + 修改CSS的class
```
const el = document.getElementById('test'); 
el.style.cssText += 'border-left: 1px; border-right: 2px; padding: 5px;';

const el = document.getElementById('test');
el.className += ' active';
```
+ （考虑级别最低）**批量修改DOM**：当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数：
1. 使元素脱离文档流
2. 对其进行多次修改
3. 将元素带回到文档中。
4. **现代浏览器会使用队列来储存多次修改，进行优化，所以对这个优化方案，我们其实不用优先考虑**。
+ 该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对DOM的所有修改都不会引起回流重绘，因为它已经不在渲染树了。有三种方式可以让DOM脱离文档流：
    + 隐藏元素，应用修改，重新显示
    + 使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。
    + 将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。
+ **避免触发同步布局事件**：比如说我们想将一个p标签数组的宽度赋值为一个元素的宽度
```
function initP() {
    for (let i = 0; i < paragraphs.length; i++) {
        paragraphs[i].style.width = box.offsetWidth + 'px';
    }
}
```
在每次循环的时候，都读取了box的一个offsetWidth属性值，然后利用它来更新p标签的width属性。这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。**每一次循环都会强制浏览器刷新队列**。我们可以优化为:
```
const width = box.offsetWidth;
function initP() {
    for (let i = 0; i < paragraphs.length; i++) {
        paragraphs[i].style.width = width + 'px';
    }
}
```
+ **对于复杂动画效果,使用绝对定位让其脱离文档流**:对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流.
+ **css3硬件加速（GPU加速）**:比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。
    +  **使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘**。
    + **对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能**。
    + css3硬件加速的坑:
        + 如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。
        + 在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。


##### 1.HTML解析
+ HTML解析是浏览器的HTML解析器把HTML解析成dom tree，而在解析过程，浏览器根据HTML文件的结构从上到下解析html，HTML元素是以深度优先的方式解析，而script、link、style等标签会使解析过程产生阻塞，阻塞的情况有：
    1. 外部样式会阻塞内部脚本的执行。
    2. 外部样式与外部脚本并行加载，但外部样式会阻塞外部脚本执行。
    3. 如果外部脚本带有async属性，则外部脚本的加载与执行不受外部样式影响
    4. 如果link标签是动态创建（js生成），不管有无async属性，都不会阻塞外部脚本的加载与执行。

##### 2.CSS解析
+ 在对样式解析的过程中，默认CSS选择器是从右往左进行解析的。这样做比从左到右解析复杂度，重合度低。

##### 3.脚本执行
+ 浏览器解析HTML时，当遇到<script>标签就会立即解析脚本，同时阻塞解析文档直到脚本执行完毕（你可能问为什么要这样设计，明显啊，脚本的执行是改变css和dom，会造成render tree不停的重绘和重排的），而当<script>是引入外部js文件时，会阻塞到js文件下载完成并且执行完成为止（除非加了defer或者async属性）。脚本在解析过程中将对dom或css的操作解析出来加入到DOM Tree和cssom中。

### 性能优化
+ 对于CSS:
    + 优化选择器路径：健全的css选择器固然是能让开发看起来更清晰，然后对于css的解析来说却是个很大的性能问题，因此相比于 .a .b .c{} ，更倾向于大家写.c{}。
    + 压缩文件：尽可能的压缩你的css文件大小，减少资源下载的负担。
    + 选择器合并：把有共同的属性内容的一系列选择器组合到一起，能压缩空间和资源开销
    + 精准样式：尽可能减少不必要的属性设置，比如你只要设置{padding-left:10px}的值,那就避免{padding:0 0 0 10px}这样的写法
    + 雪碧图：在合理的地方把一些小的图标合并到一张图中，这样所有的图片只需要一次请求，然后通过定位的方式获取相应的图标，这样能避免一个图标一次请求的资源浪费。
    + 少用Float:Float在渲染时计算量比较大，尽量减少使用。
    + 0值去单位：对于为0的值，尽量不要加单位，增加兼容性
+ 对于JavaScript：
    + 尽可能把script标签放到body之后，避免页面需要等待js执行完成之后dom才能继续执行，最大程度保证页面尽快的展示出来。
        + 使用脚本时，对于所有位于脚本以下的内容，逐条呈现都被阻塞了。将脚本放在页面越靠下的地方，意味着越多的内容能够逐条地呈现。
        + 很多情况下，很难将脚本移到底部，例如使用document.write向页面中插入内容时。经常出现的另一种建议是使用延迟(Deferred)脚本，DEFER属性表明脚本不包含document.write，浏览器得到这一线索可继续进行呈现。但是，如果一个脚本可以延迟，那么一定可以移到页面底部。    
    + css能干的事情，尽量不要用JavaScript来干。毕竟JavaScript的解析执行过于直接和粗暴，而css效率更高。
    + 尽可能压缩的js文件，减少资源下载的负担
    + 尽可能避免在js中逐条操作dom样式，尽可能预定义好css样式，然后通过改变样式名来修改dom样式，这样集中式的操作能减少reflow或repaint的次数。
    + 尽可能少的在js中创建dom，而是预先埋到HTML中用display:none来隐藏，在js中按需调用，减少js对dom的暴力操作。
+ 对于HTML:
    + 避免在HTML中直接写css代码。
    + 使用Viewport加速页面的渲染。
    + 使用语义化标签，减少css的代码，增加可读性和SEO。
    + 减少标签的使用，dom解析是一个大量遍历的过程，减少无必要的标签，能降低遍历的次数。
    + 避免src、href等的值为空。
